import 'package:flutter/material.dart';
import '../models/wallet.dart';
import '../repositories/wallet_repository.dart';

class WalletService extends ChangeNotifier {
  static final WalletService _instance = WalletService._internal();
  factory WalletService() => _instance;
  WalletService._internal() {
    _repository = WalletRepository();
    _loadWallets();
  }

  late final WalletRepository _repository;
  final List<Wallet> _wallets = [];
  bool _isLoading = false;
  String? _error;

  List<Wallet> get wallets => List.unmodifiable(_wallets);
  bool get isLoading => _isLoading;
  String? get error => _error;

  /// Load wallets from Supabase
  Future<void> _loadWallets() async {
    _isLoading = true;
    _error = null;
    notifyListeners();

    try {
      final wallets = await _repository.getWallets();
      _wallets.clear();
      _wallets.addAll(wallets);
      _error = null;
    } catch (e) {
      _error = e.toString();
      // Keep existing wallets if loading fails
    } finally {
      _isLoading = false;
      notifyListeners();
    }
  }

  /// Refresh wallets from Supabase
  Future<void> refreshWallets() async {
    await _loadWallets();
  }

  // Add a new wallet
  Future<void> addWallet(Wallet wallet) async {
    try {
      // Get the next display order for the new wallet
      final nextOrder = await _repository.getNextDisplayOrder();
      final walletWithOrder = wallet.copyWith(displayOrder: nextOrder);

      final createdWallet = await _repository.createWallet(walletWithOrder);
      _wallets.add(createdWallet);
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  // Update an existing wallet
  Future<void> updateWallet(Wallet updatedWallet) async {
    try {
      final updated = await _repository.updateWallet(updatedWallet);
      final index = _wallets.indexWhere((w) => w.id == updatedWallet.id);
      if (index != -1) {
        _wallets[index] = updated;
        notifyListeners();
      }
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  // Delete a wallet
  Future<void> deleteWallet(String walletId) async {
    try {
      await _repository.deleteWallet(walletId);
      _wallets.removeWhere((w) => w.id == walletId);
      notifyListeners();
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  // Get a wallet by ID
  Wallet? getWalletById(String id) {
    try {
      return _wallets.firstWhere((w) => w.id == id);
    } catch (e) {
      return null;
    }
  }

  // Get a wallet by name
  Wallet? getWalletByName(String name) {
    try {
      return _wallets.firstWhere((w) => w.name == name);
    } catch (e) {
      return null;
    }
  }

  // Get wallets by type
  List<Wallet> getWalletsByType(WalletType type) {
    return _wallets.where((w) => w.type == type).toList();
  }

  // Check if wallet name already exists
  Future<bool> isWalletNameExists(String name, {String? excludeId}) async {
    try {
      return await _repository.isWalletNameExists(name, excludeId: excludeId);
    } catch (e) {
      // Fallback to local check if repository fails
      return _wallets.any(
        (w) =>
            w.name.toLowerCase() == name.toLowerCase() &&
            (excludeId == null || w.id != excludeId),
      );
    }
  }

  // Convert wallets to legacy format for backward compatibility
  List<Map<String, dynamic>> getWalletsInLegacyFormat() {
    return _wallets.map((wallet) => wallet.toLegacyFormat()).toList();
  }

  // Generate a unique ID for new wallets (UUID will be generated by Supabase)
  String generateWalletId() {
    return 'temp_${DateTime.now().millisecondsSinceEpoch}';
  }

  // Update local wallet order immediately (for UI responsiveness)
  void updateLocalWalletOrder(List<Wallet> reorderedWallets) {
    _wallets.clear();
    _wallets.addAll(reorderedWallets);
    notifyListeners();
  }

  // Update wallet display order
  Future<void> updateWalletDisplayOrder(List<Wallet> reorderedWallets) async {
    try {
      // Create list of wallet orders for the repository
      final walletOrders = reorderedWallets.asMap().entries.map((entry) {
        return {'wallet_id': entry.value.id, 'display_order': entry.key};
      }).toList();

      // Update in Supabase
      await _repository.updateWalletDisplayOrder(walletOrders);
    } catch (e) {
      _error = e.toString();
      notifyListeners();
      rethrow;
    }
  }

  // Get total balance across all wallets
  double getTotalBalance() {
    return _wallets.fold(0.0, (sum, wallet) => sum + wallet.initialValue);
  }

  // Get formatted total balance
  String getFormattedTotalBalance() {
    final total = getTotalBalance();
    return 'IDR ${_formatCurrency(total)}';
  }

  String _formatCurrency(double amount) {
    return amount
        .toStringAsFixed(2)
        .replaceAllMapped(
          RegExp(r'(\d)(?=(\d{3})+(?!\d))'),
          (Match m) => '${m[1]},',
        );
  }

  // Predefined colors for wallets
  static const List<Color> walletColors = [
    Colors.blue,
    Colors.green,
    Colors.orange,
    Colors.purple,
    Colors.red,
    Colors.teal,
    Colors.indigo,
    Colors.pink,
    Colors.cyan,
    Colors.amber,
    Color(0xFF8D6E63), // Brown
    Colors.grey,
    Colors.deepOrange,
    Colors.lightBlue,
    Colors.lime,
    Colors.deepPurple,
  ];
}
